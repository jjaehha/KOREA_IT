
 ---------------------------------------------------------------------------- 

 크기 단위
    1. px
        그래픽의 최소 단위, 모니터로 본다면 해상도
        절대 크기 지정 방식, 내가 정해준 크기가 어떠한 경우에도 그대로인 것

    2. rem
        html 최상의 요소 ( <html> )의 fontsize의 배율
        사용자 브라우저 환경 마다 다르게 설정할 수 있지만 기본 값은 16px
        (김성용의 컴퓨터에서 크롬의 기본 포트 크기는 14px)

        1rem = 16px (14px)
        1.5rem = 24px (21px)
        2rem = 32px (28px)

    3. em
        상위 요소(부모 요소)의 fontsize의 배율

        ex)
            <div style="font-sizle:32px;">
                <p style="font-size: 2em"> ----- ? 64px
                    ...
                </p>
            </div>

    4. %
        기준이 되는 요소(position : relative, 보통은 부모 요소)
        와의 비율

        ex)
            <div> --- width: 500px
                <p> --- widht : 70% ---> 350px

    5. vw, vh
        vw, vh (viewport width/ height)
        *사용자가 보고 있는* 디스플레이 화면의 100%길이와 100%높이

        ex) 사용자가 가로 1920px의 해상도로 화면을 보고 있다면
            100vw는 1920px이다

        주의, 마우스 스크롤의 길이를 포함하지 않습니다.
        그렇기 때문에 스크롤 및 여백에 의해 가로 스크롤이 생길 수 있음

    6. calc
        계산 기능

        ex)
            height: calc (100vh - 80px)
            * 띄어쓰기 꼭 지켜야함

 ---------------------------------------------------------------------------- 

 HTML 파싱과정, google.com을 주소창에 입력했을 때 일어나는 일?

    1)
        google.com 주소에 입력
        도메인(google.com)을 통해 DNS(Domain Name Sever)에서 상응하는 ip주소를 탐색
        해당 ip주소에 페이지를 랜더하기 위한 리소스를 요청 (ima, font, html, css, js ... )
        -----> 브라우저 엔진이 리소스를 받고 html, css ,js 파싱 및 실행

        웹서버가 혼자서 페이지를 랜더링하고 백엔드 데이터하기가 부담
        WAS(서버의 도우미) 데이터 요청, 응답 ex) tomcat

        백엔드에 받아온 데이터를 웹 브라우저에 전송하고 받아온 데이터를 토대로
        페이지 파싱을 완료하여 렌더(화면을 그린다)


    2)  
        파싱과정

        1)을 통해서 받은 전달 받은 리소를 브라우저 로더가 분석
        HTML, CSS, JS, MEDIA...
        DOM TREE, CSS OM, JS --->  javascript 엔진 (평가/실행)
        DOM TREE + CSS OM ------> 랜더링트리 (F12)

        랜터링 트리를 토대로 정해진 CSS를 실제 화면에 표현대기 위해 적용
        (레이아웃 과정 (크기,위치))

        페인트 (화면이 사용자에게 노출)

        * 사용자의 행위에 따라 css나 html 구조는 언제든 변경이 가능
        이 경우는 레이아웃 과정과 페인트 과정을 다시 그리는 리페인트 과정을 거치게 됨

        중요한 것은 리소스를 받아오는 로드 과정부터 다시하는 것이 아닌
        기존의 받아온 리소스를 바탕으로 레이아웃을 다시 게산하여 페인트 하는 과정을 이야기 함

        html 요소 구조자체 바뀐 경우 --> 리플로우라는 과정을 함 (랜더링 트리를 다시 그림)

        * 리플로우, 리페인트
            리플로우 
                랜더링 트리를 다시 그리는 과정, html 구조 변경 -> 리페인트

            리페인트
                랜더링 트리를 기반으로 시각적으로 보이는 css를 바꾸는 과정

 ---------------------------------------------------------------------------- 

 CSS의 배경

    backgrond-color
        배경색

    backgrond-image
        배경 이미지

    backgrond-repeat
        배경 이미지의 반복여부 설정
        x축, y축, 반복, 반복하지 않음

    backgrond-position
        반복되지 않는 배경 이미지의 상대 위치를 결정

    backgrond-attachment
        배경 이미지를 고정
        이미지 크기 및 스크롤과 무관하게 화면에서 배경이 움직이지 않습니다.

    backgrond-size
        베경의 크기를 설정

        1) cover 
            페이지에 가득 차게
            종횡비에 따라 이미지가 잘릴 수 있음

        2) contain
            원본 종회비에 맞게 사진이 전체가 보이도록
            사진의 크기에 따라 여백이 생길 수 있음

 ---------------------------------------------------------------------------- 

 * 다음 수업
  
  패딩, 마진, 박스사이징, 테두리 

  * 포지션, 디스플레이
  * 플렉시블 레이아웃
  * 그리드 레이아웃 (수평, 수직정렬, 위치 조정)

  미디어쿼리(컨테이너), 트랜스폼, 애니메이션, 트랜지션

  + 퍼블리싱 페이지

 ---------------------------------------------------------------------------- 